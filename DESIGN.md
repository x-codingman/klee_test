目前检测机制，以任意写为例：遇到符号指针解引用操作时，如*a=b，首先检查a与b是否都是攻击者可控制的符号值，若是，再检查a是否能指向攻击者定义的危险区域，如(if MPU_REGISITER_START < a MPU_REGISITER_END), 若是，则该位置存在问题。

问题：是否一定需要地址之间的对应关系？即KLEE运行环境的地址空间和真实程序的地址空间的映射关系。
结论：
分析：
针对程序运行过程中的符号指针X，考虑以下两种情况：
1. 如果对符号指针X，不存在地址范围约束，那么X可以指向全域，意味着攻击者可以控制该指针指向任意内存，因此，不需要对其进行约束。
2. 如果对符号指针X，存在地址范围约束，比如针对X存在如下约束：MPU_REGION_0_START<=X<=MPU_REGION_0_END。那么在对X进行内存分配的时候，其分配的地址必须符合该约束要求。此时，若没有对应关系，为X分配的memory object的地址需要满足该约束要求才能保证程序的正常运行。存在以下两种情况：

    （1）这个地址范围可以被攻击者控制，那么对其值进行具体化，分配一块符号化的memory object给它（对于攻击者的能力，需要提前输入一个攻击者的能力范围给KLEE以便对此进行判断）。注意，该分配地址可以不满足该约束，这是因为攻击者可以控制这块内存区域，意味着该地址范围的约束内，攻击者可以任意构造内存块（对应符号化的memory object）

    （2）这个地址范围不能被攻击者所控制，那么对该地址范围内进行memory object的resolve。但
    在under constrained的情况下，我们无法获得MPU_REGION_0_START这些值，因为这些值在链接阶段才能确定。因此，为解决这个问题，我们也对其进行分配一块符号化的内存，但该符号化的内存的目的是为了程序的运行。为了将其与前面的符号内存区分，可以对该符号内存设置标志位。


