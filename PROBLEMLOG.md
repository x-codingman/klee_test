# Problemlog

## [3.3.0]
- 分支覆盖问题。对符号指针随读随分配随绑定内存的处理方式将最早具体化符号指针，从而影响由符号指针决定的程序分支覆盖情况，比如形如symbolic pointer == NULL、symbolic pointer1 > symbolic pointer2的程序分支，将由经具体化的符号指针决定分支走向，从而会省略某一分支。
- 漏洞检测机制不完善，存在由指针类型全局变量引起的漏洞误报。指针类型的全局变量不经由外部参数影响是不存在漏洞可能的，但在缺少上下文的符号执行中，全局变量也会做符号化处理，在漏洞检测时通过判断写操作中的address（指针）对应的MemoryObject无法区分出是全局变量的符号指针，从而出现误报。
- 漏洞检测机制不完善，存在由写操作的值类型引起的漏报。攻击者的目标和写操作的粒度是多样的，当前漏洞检测机制只支持检测写64位0的漏洞位置，不支持检测如写第0位为0这样更细粒度的漏洞位置。 
- 漏洞检测机制不完善，对含符号变量本身的赋值运算存在误报。例如pxTimer->ucStatus &= ( ( uint8_t ) 0xfb )这一赋值语句，其中pxTimer是一个符号指针，若想对pxTimer->ucStatus赋值为0，pxTimer->ucStatus需满足值为0或4，但这一先决条件在针对MPU的攻击场景中都不会满足。 

## [3.4.0]
- 分支覆盖问题。先创建Task再测试API的测试方式，会影响一些API的分支走向，这会影响到分支覆盖率。

## [3.5.1]
- 表达式解析问题。针对形如symbolic pointer + symbolic index的地址表达式存在不能resolve的问题。
- 内存分配问题。针对如void类型、uint8_t类型、char类型指针存在确定内存分配大小的问题。
- 漏洞检测机制不完善，存在不能完整利用的漏洞误报。当前漏洞检测机制没有考虑保证函数正常退出，对一些报告的漏洞位置的利用会引起程序后续运行的崩溃。


